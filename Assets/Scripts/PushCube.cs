using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class PushCube : MonoBehaviour
{
    [Header("Physics Parameters")]
    public float mass = 1.5f;
    public float staticFrictionCoefficient = 0.3f;
    public float kineticFrictionCoefficient = 0.1f;
    public float appliedForce = 0f;
    
    [Header("References")]
    public Rigidbody objectRb;
    public Transform startPoint;
    public Transform finishPoint;
    public TMP_Text forceText;
    public TMP_Text statusText;
    public TMP_Text distanceText;

    [Header("UI Inputs")]
    public TMP_InputField frictionCoefInput;
    public TMP_InputField cubesMassInput;      
    public TMP_InputField playerForceInput;
    public Button applyParamsButton;
    public Button restartButton;

    [Header("Finish UI")]
    public GameObject finishPanel; // –ü–∞–Ω–µ–ª—å –ø–æ–±–µ–¥—ã
    public TMP_Text resultsText;   // –¢–µ–∫—Å—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    
    // –†–∞—Å—á–µ—Ç–Ω—ã–µ –≤–µ–ª–∏—á–∏–Ω—ã
    private float gravity = 9.81f;
    private float normalForce;
    private float maxStaticFriction;
    private float kineticFriction;
    private bool isMoving = false;
    private Vector3 initialPosition;
    
    // –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ñ–∏–Ω–∏—à–∞
    private bool reachedFinish = false;
    private float finishDistance = 4f;

    void Start()
    {
        initialPosition = objectRb.position;
        RecalculateForces();

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ UI
        frictionCoefInput.text = staticFrictionCoefficient.ToString("F2");
        cubesMassInput.text = mass.ToString("F2");
        playerForceInput.text = appliedForce.ToString("F2");
        
        // –ù–∞–∑–Ω–∞—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
        applyParamsButton.onClick.AddListener(ApplyParameters);
        restartButton.onClick.AddListener(ResetObject);
        
        // –°–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ–±–µ–¥—ã
        if (finishPanel != null)
            finishPanel.SetActive(false);
        
        UpdateUI();
    }
    
    void FixedUpdate()
    {
        // –ü–†–û–í–ï–†–ö–ê –î–í–ò–ñ–ï–ù–ò–Ø - –§–ò–ö–°–ò–†–£–ï–ú –ë–ê–ì
        if (!isMoving && appliedForce > maxStaticFriction)
        {
            StartMovement();
        }
        
        // –ï—Å–ª–∏ –æ–±—ä–µ–∫—Ç –¥–≤–∏–∂–µ—Ç—Å—è, –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—É —Ç—Ä–µ–Ω–∏—è
        if (isMoving)
        {
            ApplyKineticFriction();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å—Ç–∞–Ω–æ–≤–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–∏–ª–∞ –º–µ–Ω—å—à–µ —Ç—Ä–µ–Ω–∏—è
            if (objectRb.linearVelocity.magnitude < 0.1f && appliedForce <= kineticFriction)
            {
                StopMovement();
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ñ–∏–Ω–∏—à–∞
            CheckFinish();
        }
        
        UpdateUI();
    }
    
    public void ApplyParameters()
    {
        // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Å—Å—É
        if (float.TryParse(cubesMassInput.text, out float newMass) && newMass > 0)
        {
            mass = newMass;
            objectRb.mass = mass;
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Ç—Ä–µ–Ω–∏—è
        if (float.TryParse(frictionCoefInput.text, out float newFriction) && newFriction >= 0)
        {
            staticFrictionCoefficient = newFriction;
            kineticFrictionCoefficient = newFriction * 0.7f; // –ö–∏–Ω–µ—Ç–∏—á–µ—Å–∫–æ–µ –≤—Å–µ–≥–¥–∞ –º–µ–Ω—å—à–µ
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–Ω—É—é —Å–∏–ª—É
        if (float.TryParse(playerForceInput.text, out float newForce) && newForce >= 0)
        {
            appliedForce = newForce;
        }
        
        RecalculateForces();
        Debug.Log($"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã: –ú–∞—Å—Å–∞={mass}, –¢—Ä–µ–Ω–∏–µ={staticFrictionCoefficient}, –°–∏–ª–∞={appliedForce}");
    }
    
    public void SetAppliedForce(float force)
    {
        appliedForce = force;
        playerForceInput.text = force.ToString("F2");
        
        // –°–†–ê–ó–£ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –Ω–∞—á–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ
        if (!isMoving && appliedForce > maxStaticFriction)
        {
            StartMovement();
        }
    }
    
    public void SetMass(float newMass)
    {
        mass = newMass;
        objectRb.mass = mass;
        cubesMassInput.text = mass.ToString("F2");
        RecalculateForces();
    }
    
    public void SetStaticFriction(float friction)
    {
        staticFrictionCoefficient = friction;
        frictionCoefInput.text = friction.ToString("F2");
        RecalculateForces();
    }
    
    private void RecalculateForces()
    {
        normalForce = mass * gravity;
        maxStaticFriction = staticFrictionCoefficient * normalForce;
        kineticFriction = kineticFrictionCoefficient * normalForce;
    }
    
    private void StartMovement()
    {
        isMoving = true;
        reachedFinish = false;
        
        // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–∏–ª—ã
        objectRb.linearVelocity = Vector3.zero;
        
        // –ü—Ä–∏–∫–ª–∞–¥—ã–≤–∞–µ–º –∏–∑–±—ã—Ç–æ—á–Ω—É—é —Å–∏–ª—É
        float netForce = appliedForce - kineticFriction;
        if (netForce > 0)
        {
            objectRb.AddForce(Vector3.right * netForce, ForceMode.Force);
            Debug.Log($"–ù–∞—á–∞—Ç–æ –¥–≤–∏–∂–µ–Ω–∏–µ! –°–∏–ª–∞: {netForce:F2}N");
        }
    }
    
    private void ApplyKineticFriction()
    {
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—É —Ç—Ä–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ
        if (objectRb.linearVelocity.magnitude > 0.01f)
        {
            Vector3 frictionForce = -objectRb.linearVelocity.normalized * kineticFriction;
            objectRb.AddForce(frictionForce, ForceMode.Force);
        }
    }
    
    public void StopMovement()
    {
        isMoving = false;
        objectRb.linearVelocity = Vector3.zero;
    }
    
    private void CheckFinish()
    {
        if (!reachedFinish)
        {
            float currentDistance = Vector3.Distance(objectRb.position, startPoint.position);
            if (currentDistance >= finishDistance)
            {
                reachedFinish = true;
                OnFinishReached();
            }
        }
    }
    
    public void OnFinishReached()
    {
        Debug.Log($"üéâ –§–ò–ù–ò–®! –û–±—ä–µ–∫—Ç –ø—Ä–æ—à–µ–ª {finishDistance} –º–µ—Ç—Ä–æ–≤!");
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ–±–µ–¥—ã
        if (finishPanel != null)
        {
            finishPanel.SetActive(true);
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            float actualDistance = Vector3.Distance(startPoint.position, objectRb.position);
            float time = Time.timeSinceLevelLoad;
            
            resultsText.text = 
                $"üéâ –§–ò–ù–ò–®! üéâ\n\n" +
                $"–ü—Ä–æ–π–¥–µ–Ω–æ: {actualDistance:F2} –º\n" +
                $"–ú–∞—Å—Å–∞: {mass:F1} –∫–≥\n" +
                $"–¢—Ä–µ–Ω–∏–µ: {staticFrictionCoefficient:F2}\n" +
                $"–°–∏–ª–∞: {appliedForce:F1} –ù\n" +
                $"–í—Ä–µ–º—è: {time:F1} —Å–µ–∫";
        }
        
        // –ú–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å
        if (statusText != null)
        {
            statusText.color = Color.green;
            statusText.text = "–§–ò–ù–ò–® –î–û–°–¢–ò–ì–ù–£–¢!";
        }
        
        StopMovement();
    }
    
    public void ResetObject()
    {
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–∏–∑–∏–∫—É
        objectRb.linearVelocity = Vector3.zero;
        objectRb.angularVelocity = Vector3.zero;
        objectRb.position = initialPosition;
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        isMoving = false;
        reachedFinish = false;
        
        // –°–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ–±–µ–¥—ã
        if (finishPanel != null)
            finishPanel.SetActive(false);
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º UI
        if (statusText != null)
        {
            statusText.color = Color.white;
        }
        
        UpdateUI();
        Debug.Log("–û–±—ä–µ–∫—Ç —Å–±—Ä–æ—à–µ–Ω –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ");
    }
    
    private void UpdateUI()
    {
        if (forceText != null)
            forceText.text = $"–°–∏–ª–∞: {appliedForce:F2} N\n" +
                           $"–°—Ç–∞—Ç–∏—á. —Ç—Ä–µ–Ω–∏–µ: {maxStaticFriction:F2} N\n" +
                           $"–ö–∏–Ω–µ—Ç. —Ç—Ä–µ–Ω–∏–µ: {kineticFriction:F2} N";
        
        if (statusText != null && !reachedFinish)
        {
            string status = isMoving ? "–î–í–ò–ñ–ï–¢–°–Ø" : "–ü–û–ö–û–ò–¢–°–Ø";
            statusText.text = $"{status}\n–°–∫–æ—Ä–æ—Å—Ç—å: {objectRb.linearVelocity.magnitude:F2} m/s";
        }
        
        if (distanceText != null)
        {
            float distanceFromStart = Vector3.Distance(objectRb.position, startPoint.position);
            float distanceToFinish = Mathf.Max(0, finishDistance - distanceFromStart);
            
            distanceText.text = $"–û—Ç —Å—Ç–∞—Ä—Ç–∞: {distanceFromStart:F2} m\n" +
                              $"–î–æ —Ñ–∏–Ω–∏—à–∞: {distanceToFinish:F2} m\n" +
                              $"–¶–µ–ª—å: {finishDistance} m";
        }
    }
}